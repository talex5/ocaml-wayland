<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Xdg_surface (wayland.Wayland_protocols.Xdg_shell_client.Xdg_surface)</title><link rel="stylesheet" href="../../../../odoc.support/odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc v2.3.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../../index.html">wayland</a> &#x00BB; <a href="../../index.html">Wayland_protocols</a> &#x00BB; <a href="../index.html">Xdg_shell_client</a> &#x00BB; Xdg_surface</nav><header class="odoc-preamble"><h1>Module <code><span>Xdg_shell_client.Xdg_surface</span></code></h1><p>Desktop user interface surface base interface.</p><p>An interface that may be implemented by a wl_surface, for implementations that provide a desktop-style user interface.</p><p>It provides a base set of functionality required to construct user interface elements requiring management by the compositor, such as toplevel windows, menus, etc. The types of functionality are split into xdg_surface roles.</p><p>Creating an xdg_surface does not set the role for a wl_surface. In order to map an xdg_surface, the client must create a role-specific object using, e.g., get_toplevel, get_popup. The wl_surface for any given xdg_surface can have at most one role, and may not be assigned any role not based on xdg_surface.</p><p>A role must be assigned before any other requests are made to the xdg_surface object.</p><p>The client must call wl_surface.commit on the corresponding wl_surface for the xdg_surface state to take effect.</p><p>Creating an xdg_surface from a wl_surface which has a buffer attached or committed is a client error, and any attempts by a client to attach or manipulate a buffer prior to the first xdg_surface.configure call must also be treated as errors.</p><p>After creating a role-specific object and setting it up, the client must perform an initial commit without any buffer attached. The compositor will reply with initial wl_surface state such as wl_surface.preferred_buffer_scale followed by an xdg_surface.configure event. The client must acknowledge it and is then allowed to attach a buffer to map the surface.</p><p>Mapping an xdg_surface-based role surface is defined as making it possible for the surface to be shown by the compositor. Note that a mapped surface is not guaranteed to be visible once it is mapped.</p><p>For an xdg_surface to be mapped by the compositor, the following conditions must be met: (1) the client has assigned an xdg_surface-based role to the surface (2) the client has set and committed the xdg_surface state and the role-dependent state to the surface (3) the client has committed a buffer to the surface</p><p>A newly-unmapped surface is considered to have met condition (1) out of the 3 required conditions for mapping a surface if its role surface has not been destroyed, i.e. the client must perform the initial commit again before attaching a buffer.</p></header><nav class="odoc-toc"><ul><li><a href="#version-1,-2,-3,-4,-5,-6">Version 1, 2, 3, 4, 5, 6</a></li><li><a href="#handlers">Handlers</a></li></ul></nav><div class="odoc-content"><div class="odoc-spec"><div class="spec type anchored" id="type-t"><a href="#type-t" class="anchor"></a><code><span><span class="keyword">type</span> <span>'v t</span></span><span> = <span><span>(<span>[ `Xdg_surface ]</span>, <span class="type-var">'v</span>, <span>[ `Client ]</span>)</span> <a href="../../../Wayland/Proxy/index.html#type-t">Wayland.Proxy.t</a></span></span></code></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-Error"><a href="#module-Error" class="anchor"></a><code><span><span class="keyword">module</span> Error</span><span> = <a href="../../Xdg_shell_proto/Xdg_surface/Error/index.html">Xdg_shell_proto.Xdg_surface.Error</a></span></code></div></div><h3 id="version-1,-2,-3,-4,-5,-6"><a href="#version-1,-2,-3,-4,-5,-6" class="anchor"></a>Version 1, 2, 3, 4, 5, 6</h3><div class="odoc-spec"><div class="spec value anchored" id="val-ack_configure"><a href="#val-ack_configure" class="anchor"></a><code><span><span class="keyword">val</span> ack_configure : 
  <span><span><span>[&lt; `V1 <span>| `V2</span> <span>| `V3</span> <span>| `V4</span> <span>| `V5</span> <span>| `V6</span> ]</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">serial</span>:int32 <span class="arrow">&#45;&gt;</span></span>
  unit</span></code></div><div class="spec-doc"><p>Ack a configure event.</p><p>When a configure event is received, if a client commits the surface in response to the configure event, then the client must make an ack_configure request sometime before the commit request, passing along the serial of the configure event.</p><p>For instance, for toplevel surfaces the compositor might use this information to move a surface to the top left only when the client has drawn itself for the maximized or fullscreen state.</p><p>If the client receives multiple configure events before it can respond to one, it only has to ack the last configure event. Acking a configure event that was never sent raises an invalid_serial error.</p><p>A client is not required to commit immediately after sending an ack_configure request - it may even ack_configure several times before its next surface commit.</p><p>A client may send multiple ack_configure requests before committing, but only the last request sent before a commit indicates which configure event the client really is responding to.</p><p>Sending an ack_configure request consumes the serial number sent with the request, as well as serial numbers sent by all configure events sent on this xdg_surface prior to the configure event referenced by the committed serial.</p><p>It is an error to issue multiple ack_configure requests referencing a serial from the same configure event, or to issue an ack_configure request referencing a serial from a configure event issued before the event identified by the last ack_configure request for the same xdg_surface. Doing so will raise an invalid_serial error.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-set_window_geometry"><a href="#val-set_window_geometry" class="anchor"></a><code><span><span class="keyword">val</span> set_window_geometry : 
  <span><span><span>[&lt; `V1 <span>| `V2</span> <span>| `V3</span> <span>| `V4</span> <span>| `V5</span> <span>| `V6</span> ]</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">x</span>:int32 <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">y</span>:int32 <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">width</span>:int32 <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">height</span>:int32 <span class="arrow">&#45;&gt;</span></span>
  unit</span></code></div><div class="spec-doc"><p>Set the new window geometry.</p><p>The window geometry of a surface is its &quot;visible bounds&quot; from the user's perspective. Client-side decorations often have invisible portions like drop-shadows which should be ignored for the purposes of aligning, placing and constraining windows.</p><p>The window geometry is double buffered, and will be applied at the time wl_surface.commit of the corresponding wl_surface is called.</p><p>When maintaining a position, the compositor should treat the (x, y) coordinate of the window geometry as the top left corner of the window. A client changing the (x, y) window geometry coordinate should in general not alter the position of the window.</p><p>Once the window geometry of the surface is set, it is not possible to unset it, and it will remain the same until set_window_geometry is called again, even if a new subsurface or buffer is attached.</p><p>If never set, the value is the full bounds of the surface, including any subsurfaces. This updates dynamically on every commit. This unset is meant for extremely simple clients.</p><p>The arguments are given in the surface-local coordinate space of the wl_surface associated with this xdg_surface, and may extend outside of the wl_surface itself to mark parts of the subsurface tree as part of the window geometry.</p><p>When applied, the effective window geometry will be the set window geometry clamped to the bounding rectangle of the combined geometry of the surface of the xdg_surface and the associated subsurfaces.</p><p>The effective geometry will not be recalculated unless a new call to set_window_geometry is done and the new pending surface state is subsequently applied.</p><p>The width and height of the effective window geometry must be greater than zero. Setting an invalid size will raise an invalid_size error.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-get_popup"><a href="#val-get_popup" class="anchor"></a><code><span><span class="keyword">val</span> get_popup : 
  <span><span><span>[&lt; `V1 <span>| `V2</span> <span>| `V3</span> <span>| `V4</span> <span>| `V5</span> <span>| `V6</span> ]</span> <span class="keyword">as</span> 'a <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>[<span>[ `Xdg_popup ]</span>, <span class="type-var">'b</span>, <span>[ `Client ]</span>]</span> <a href="../../../Wayland/Proxy/Handler/class-type-t/index.html">Wayland.Proxy.Handler.t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">parent</span>:<span><span><span>(<span>[ `Xdg_surface ]</span>, <span class="type-var">'c</span>, <span>[ `Client ]</span>)</span> <a href="../../../Wayland/Proxy/index.html#type-t">Wayland.Proxy.t</a></span> option</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">positioner</span>:<span><span>(<span>[ `Xdg_positioner ]</span>, <span class="type-var">'d</span>, <span>[ `Client ]</span>)</span> <a href="../../../Wayland/Proxy/index.html#type-t">Wayland.Proxy.t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span>[ `Xdg_popup ]</span>, <span class="type-var">'e</span>, <span>[ `Client ]</span>)</span> <a href="../../../Wayland/Proxy/index.html#type-t">Wayland.Proxy.t</a></span></span></code></div><div class="spec-doc"><p>Assign the xdg_popup surface role.</p><p>This creates an xdg_popup object for the given xdg_surface and gives the associated wl_surface the xdg_popup role.</p><p>If null is passed as a parent, a parent surface must be specified using some other protocol, before committing the initial state.</p><p>See the documentation of xdg_popup for more details about what an xdg_popup is and how it is used.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-get_toplevel"><a href="#val-get_toplevel" class="anchor"></a><code><span><span class="keyword">val</span> get_toplevel : 
  <span><span><span>[&lt; `V1 <span>| `V2</span> <span>| `V3</span> <span>| `V4</span> <span>| `V5</span> <span>| `V6</span> ]</span> <span class="keyword">as</span> 'a <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>[<span>[ `Xdg_toplevel ]</span>, <span class="type-var">'b</span>, <span>[ `Client ]</span>]</span> <a href="../../../Wayland/Proxy/Handler/class-type-t/index.html">Wayland.Proxy.Handler.t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span>[ `Xdg_toplevel ]</span>, <span class="type-var">'c</span>, <span>[ `Client ]</span>)</span> <a href="../../../Wayland/Proxy/index.html#type-t">Wayland.Proxy.t</a></span></span></code></div><div class="spec-doc"><p>Assign the xdg_toplevel surface role.</p><p>This creates an xdg_toplevel object for the given xdg_surface and gives the associated wl_surface the xdg_toplevel role.</p><p>See the documentation of xdg_toplevel for more details about what an xdg_toplevel is and how it is used.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-destroy"><a href="#val-destroy" class="anchor"></a><code><span><span class="keyword">val</span> destroy : <span><span><span>[&lt; `V1 <span>| `V2</span> <span>| `V3</span> <span>| `V4</span> <span>| `V5</span> <span>| `V6</span> ]</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>Destroy the xdg_surface.</p><p>Destroy the xdg_surface object. An xdg_surface must only be destroyed after its role object has been destroyed, otherwise a defunct_role_object error is raised.</p></div></div><h3 id="handlers"><a href="#handlers" class="anchor"></a>Handlers</h3><p>Note: Servers will always want to use <code>v1</code>.</p><div class="odoc-spec"><div class="spec class anchored" id="class-v1"><a href="#class-v1" class="anchor"></a><code><span><span class="keyword">class</span> <span class="keyword">virtual</span> +'a </span><span><a href="class-v1/index.html">v1</a></span><span> : <span class="keyword">object</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>Handler for a proxy with version &gt;= 1.</p></div></div><div class="odoc-spec"><div class="spec class anchored" id="class-v2"><a href="#class-v2" class="anchor"></a><code><span><span class="keyword">class</span> <span class="keyword">virtual</span> +'a </span><span><a href="class-v2/index.html">v2</a></span><span> : <span class="keyword">object</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>Handler for a proxy with version &gt;= 2.</p></div></div><div class="odoc-spec"><div class="spec class anchored" id="class-v3"><a href="#class-v3" class="anchor"></a><code><span><span class="keyword">class</span> <span class="keyword">virtual</span> +'a </span><span><a href="class-v3/index.html">v3</a></span><span> : <span class="keyword">object</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>Handler for a proxy with version &gt;= 3.</p></div></div><div class="odoc-spec"><div class="spec class anchored" id="class-v4"><a href="#class-v4" class="anchor"></a><code><span><span class="keyword">class</span> <span class="keyword">virtual</span> +'a </span><span><a href="class-v4/index.html">v4</a></span><span> : <span class="keyword">object</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>Handler for a proxy with version &gt;= 4.</p></div></div><div class="odoc-spec"><div class="spec class anchored" id="class-v5"><a href="#class-v5" class="anchor"></a><code><span><span class="keyword">class</span> <span class="keyword">virtual</span> +'a </span><span><a href="class-v5/index.html">v5</a></span><span> : <span class="keyword">object</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>Handler for a proxy with version &gt;= 5.</p></div></div><div class="odoc-spec"><div class="spec class anchored" id="class-v6"><a href="#class-v6" class="anchor"></a><code><span><span class="keyword">class</span> <span class="keyword">virtual</span> +'a </span><span><a href="class-v6/index.html">v6</a></span><span> : <span class="keyword">object</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>Handler for a proxy with version &gt;= 6.</p></div></div></div></body></html>
