<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>v1 (wayland.Wayland_protocols.Xdg_shell_server.Xdg_surface.v1)</title><meta charset="utf-8"/><link rel="stylesheet" href="../../../../../odoc.support/odoc.css"/><meta name="generator" content="odoc 2.4.1"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../../../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../../../index.html">wayland</a> &#x00BB; <a href="../../../index.html">Wayland_protocols</a> &#x00BB; <a href="../../index.html">Xdg_shell_server</a> &#x00BB; <a href="../index.html">Xdg_surface</a> &#x00BB; v1</nav><header class="odoc-preamble"><h1>Class <code><span>Xdg_surface.v1</span></code></h1><p>Handler for a proxy with version &gt;= 1.</p></header><div class="odoc-content"><div class="odoc-spec"><div class="spec"><code><span> <span class="keyword">constraint</span> <span class="type-var">'a</span> = <span>[&lt; `V1 <span>| `V2</span> <span>| `V3</span> <span>| `V4</span> <span>| `V5</span> <span>| `V6</span> ]</span></span></code></div></div><div class="odoc-spec"><div class="spec method anchored" id="method-on_destroy"><a href="#method-on_destroy" class="anchor"></a><code><span><span class="keyword">method</span> <span class="keyword">private</span> <span class="keyword">virtual</span> on_destroy : <span><span><span>[&gt; `V1 <span>| `V2</span> <span>| `V3</span> <span>| `V4</span> <span>| `V5</span> <span>| `V6</span> ]</span> <a href="../index.html#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  unit</span></code></div></div><p>Destroy the xdg_surface.</p><p>Destroy the xdg_surface object. An xdg_surface must only be destroyed after its role object has been destroyed, otherwise a defunct_role_object error is raised.</p><div class="odoc-spec"><div class="spec method anchored" id="method-on_get_toplevel"><a href="#method-on_get_toplevel" class="anchor"></a><code><span><span class="keyword">method</span> <span class="keyword">private</span> <span class="keyword">virtual</span> on_get_toplevel : <span><span><span>[&gt; `V1 <span>| `V2</span> <span>| `V3</span> <span>| `V4</span> <span>| `V5</span> <span>| `V6</span> ]</span>
                                           <a href="../index.html#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<span>[ `Xdg_toplevel ]</span>, <span class="type-var">'b</span>, <span>[ `Server ]</span>)</span> <span class="xref-unresolved">{Proxy}2</span>.t</span> <span class="arrow">&#45;&gt;</span></span>
  unit</span></code></div></div><p>Assign the xdg_toplevel surface role.</p><p>This creates an xdg_toplevel object for the given xdg_surface and gives the associated wl_surface the xdg_toplevel role.</p><p>See the documentation of xdg_toplevel for more details about what an xdg_toplevel is and how it is used.</p><div class="odoc-spec"><div class="spec method anchored" id="method-on_get_popup"><a href="#method-on_get_popup" class="anchor"></a><code><span><span class="keyword">method</span> <span class="keyword">private</span> <span class="keyword">virtual</span> on_get_popup : <span><span><span>[&gt; `V1 <span>| `V2</span> <span>| `V3</span> <span>| `V4</span> <span>| `V5</span> <span>| `V6</span> ]</span> <a href="../index.html#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<span>[ `Xdg_popup ]</span>, <span class="type-var">'b</span>, <span>[ `Server ]</span>)</span> <span class="xref-unresolved">{Proxy}2</span>.t</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">parent</span>:
    <span><span><span>(<span>[ `Xdg_surface ]</span>, <span>[&gt; <span class="xref-unresolved">{Imports}1</span>.Xdg_surface.versions ]</span>, <span>[ `Server ]</span>)</span>
      <span class="xref-unresolved">{Proxy}2</span>.t</span>
      option</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">positioner</span>:
    <span><span>(<span>[ `Xdg_positioner ]</span>, <span>[&gt; <span class="xref-unresolved">{Imports}1</span>.Xdg_positioner.versions ]</span>, <span>[ `Server ]</span>)</span>
      <span class="xref-unresolved">{Proxy}2</span>.t</span> <span class="arrow">&#45;&gt;</span></span>
  unit</span></code></div></div><p>Assign the xdg_popup surface role.</p><p>This creates an xdg_popup object for the given xdg_surface and gives the associated wl_surface the xdg_popup role.</p><p>If null is passed as a parent, a parent surface must be specified using some other protocol, before committing the initial state.</p><p>See the documentation of xdg_popup for more details about what an xdg_popup is and how it is used.</p><div class="odoc-spec"><div class="spec method anchored" id="method-on_set_window_geometry"><a href="#method-on_set_window_geometry" class="anchor"></a><code><span><span class="keyword">method</span> <span class="keyword">private</span> <span class="keyword">virtual</span> on_set_window_geometry : <span><span><span>[&gt; `V1
                                                <span>| `V2</span>
                                                <span>| `V3</span>
                                                <span>| `V4</span>
                                                <span>| `V5</span>
                                                <span>| `V6</span> ]</span>
                                                  <a href="../index.html#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">x</span>:int32 <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">y</span>:int32 <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">width</span>:int32 <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">height</span>:int32 <span class="arrow">&#45;&gt;</span></span>
  unit</span></code></div></div><p>Set the new window geometry.</p><p>The window geometry of a surface is its &quot;visible bounds&quot; from the user's perspective. Client-side decorations often have invisible portions like drop-shadows which should be ignored for the purposes of aligning, placing and constraining windows.</p><p>The window geometry is double buffered, and will be applied at the time wl_surface.commit of the corresponding wl_surface is called.</p><p>When maintaining a position, the compositor should treat the (x, y) coordinate of the window geometry as the top left corner of the window. A client changing the (x, y) window geometry coordinate should in general not alter the position of the window.</p><p>Once the window geometry of the surface is set, it is not possible to unset it, and it will remain the same until set_window_geometry is called again, even if a new subsurface or buffer is attached.</p><p>If never set, the value is the full bounds of the surface, including any subsurfaces. This updates dynamically on every commit. This unset is meant for extremely simple clients.</p><p>The arguments are given in the surface-local coordinate space of the wl_surface associated with this xdg_surface, and may extend outside of the wl_surface itself to mark parts of the subsurface tree as part of the window geometry.</p><p>When applied, the effective window geometry will be the set window geometry clamped to the bounding rectangle of the combined geometry of the surface of the xdg_surface and the associated subsurfaces.</p><p>The effective geometry will not be recalculated unless a new call to set_window_geometry is done and the new pending surface state is subsequently applied.</p><p>The width and height of the effective window geometry must be greater than zero. Setting an invalid size will raise an invalid_size error.</p><div class="odoc-spec"><div class="spec method anchored" id="method-on_ack_configure"><a href="#method-on_ack_configure" class="anchor"></a><code><span><span class="keyword">method</span> <span class="keyword">private</span> <span class="keyword">virtual</span> on_ack_configure : <span><span><span>[&gt; `V1
                                          <span>| `V2</span>
                                          <span>| `V3</span>
                                          <span>| `V4</span>
                                          <span>| `V5</span>
                                          <span>| `V6</span> ]</span>
                                            <a href="../index.html#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">serial</span>:int32 <span class="arrow">&#45;&gt;</span></span>
  unit</span></code></div></div><p>Ack a configure event.</p><p>When a configure event is received, if a client commits the surface in response to the configure event, then the client must make an ack_configure request sometime before the commit request, passing along the serial of the configure event.</p><p>For instance, for toplevel surfaces the compositor might use this information to move a surface to the top left only when the client has drawn itself for the maximized or fullscreen state.</p><p>If the client receives multiple configure events before it can respond to one, it only has to ack the last configure event. Acking a configure event that was never sent raises an invalid_serial error.</p><p>A client is not required to commit immediately after sending an ack_configure request - it may even ack_configure several times before its next surface commit.</p><p>A client may send multiple ack_configure requests before committing, but only the last request sent before a commit indicates which configure event the client really is responding to.</p><p>Sending an ack_configure request consumes the serial number sent with the request, as well as serial numbers sent by all configure events sent on this xdg_surface prior to the configure event referenced by the committed serial.</p><p>It is an error to issue multiple ack_configure requests referencing a serial from the same configure event, or to issue an ack_configure request referencing a serial from a configure event issued before the event identified by the last ack_configure request for the same xdg_surface. Doing so will raise an invalid_serial error.</p><div class="odoc-spec"><div class="spec method anchored" id="method-min_version"><a href="#method-min_version" class="anchor"></a><code><span><span class="keyword">method</span> min_version : int32</span></code></div></div></div></body></html>
